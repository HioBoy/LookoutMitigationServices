<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation=
    "http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

    <!--
    Construct an orchestrator using the Orchestrator helper. The only thing
    you'll need to provide is a configured Chain.
    -->
    <bean id="orchestrator" class="com.amazon.coral.service.helper.OrchestratorHelper">
        <constructor-arg>
            <ref bean="chain"/>
        </constructor-arg>
        <!-- Waiting for 2 minutes for coral framework to clean up its threads. (Some context here: https://issues.amazon.com/SF-1578)
             Note: This timeout HAS to be smaller then the shutdownTimeout for the ProcessManager (currently 01/2015 configured to be 200s) to be meaningful,
                   else the process manager will simply kill the process, without letting spring shutdown the beans it has created. -->
        <constructor-arg value="120000"/>
    </bean>

    <bean id="ShowExplorer" class="java.lang.Boolean">
        <constructor-arg value="#{'${domain}' != 'prod' and '${domain}' != 'prod-border' and '${domain}' != 'prod-cn' and '${domain}' != 'gamma' }"/>
    </bean>

    <!-- Configure the Chain which contains the list of Handlers to apply -->
    <bean id="chain" class="com.amazon.coral.service.helper.ChainHelper">
        <property name="handlers">
            <list>
                <bean class="com.amazon.coral.service.Log4jAwareRequestIdHandler"/>

                <!-- JLBRelay: See https://tiny.amazon.com/o8ck0f0x/wamazindeJLBROnbo22xa22_H -->
                <bean class="com.amazon.coral.support.service.SslProxySupportHandler">
                    <!-- HTTP port used to receive proxied traffic. This should match the HttpServer.httpRegularPort OpConfig -->
                    <constructor-arg value="${apollo.OCF.HttpServer.httpRegularPort}" />
                </bean>

                <bean class="com.amazon.coral.service.HttpHandler"/>
                <bean class="com.amazon.coral.service.PingHandler"/>

                <!-- Here are protocol handlers. You need at least one.-->
                <bean class="com.amazon.coral.service.http.HttpBindingHandler"/>
                <bean class="com.amazon.coral.service.HttpRpcHandler"/>

                <!-- ContentHandler has to be before the AuthenticationHandler to be able to use the Explorer. -->
                <bean class="com.amazon.coral.service.http.ContentHandler">
                    <!-- Do not show explorer in prod domains -->
                    <property name="serviceContent" ref="ShowExplorer"/>
                </bean>

                <ref bean="AuthenticationHandler"/>
                <ref bean="AuthorizationHandler"/>

                <bean class="com.amazon.coral.validate.ValidationHandler"/>

                <!-- add our throttling handlers -->
                <ref bean="IdentityThrottlingHandler" />
                <ref bean="OperationThrottlingHandler" />
                <ref bean="OperationIdentityThrottlingHandler" />

                <!-- This always comes last.-->
                <bean class="com.amazon.coral.spring.SpringActivityHandler">
                    <property name="globalInterceptorClassNames">
                        <list>
                            <!-- Log request/reply. See https://w.amazon.com/index.php/Coral/Manual/Logging/RequestLogging -->
                            <value>com.amazon.coral.service.RequestLoggingInterceptor</value>
                        </list>
                    </property>
                </bean>
            </list>
        </property>
    </bean>

    <bean class="com.amazon.coral.service.RequestLoggingInterceptor">
        <!--
        The following are the three properties available to control the output
        of the RequestLoggingInterceptor. The values shown are the defaults.
        -->
        <property name="logInput"><value>true</value></property>
        <property name="logOutput"><value>true</value></property>
        <property name="logOnlyOnError"><value>false</value></property>
    </bean>

    <bean id="AuthenticationHandler" class="com.amazon.coral.service.ARSAuthenticationHelper" depends-on="appConfigHelper">
        <constructor-arg ref="AuthNConfig"/>
        <constructor-arg ref="AuthRuntimeClient"/>
    </bean>

    <bean id="AuthNConfig" class="com.amazon.coral.service.AwsAuthNConfig">
        <property name="signingSchemes" value="V4"/>
        <property name="region" value="${realm}"/> <!-- Auth in the same region as the region where the service runs -->
        <property name="service" value="lookout"/>
        <property name="vendorCode" value="lookout"/>
        <property name="headersToSecure" value=""/>
    </bean>

    <!--
    Creating beans for authorization based on
    https://w.amazon.com/index.php/Coral/Manual/AWSAuth/Authorization1.1,
    https://w.amazon.com/index.php/AWSAuth/AuthRuntimeClient/UpgradingTo1.1, and
    https://code.amazon.com/packages/CoralAwsAuthRuntimeDemo/blobs/mainline/\-\-/spring-configuration/coral-service.xml
    -->

    <!--
    LookoutMitigationService is an internal service, and is not designed for subscriptions.
    So just using ARSAuthorizationHandler instead of ARSAuthorizationHelper that combines ARSAuthorizationHandler and ARSSubscriptionCheckHandler
    -->
    <bean id="AuthorizationHandler" class="com.amazon.coral.service.ARSAuthorizationHandler">
        <constructor-arg ref="AuthRuntimeClient"/>
        <constructor-arg>
            <map>
                <!-- Authorization strategy for individual operations -->
                <!-- All operations must be authorized, and we have a single strategy for all operations-->
                <entry key="LookoutMitigationService/*" value-ref="AuthorizationStrategy"/>
            </map>
        </constructor-arg>
    </bean>


    <!-- Strategy to employ for authorizing calls to LookoutMitigationService -->
    <bean id="AuthorizationStrategy" class="com.amazon.lookout.mitigation.service.authorization.AuthorizationStrategy">
        <constructor-arg ref="ArcConfig"/>
        <constructor-arg value="${realm}"/>
        <constructor-arg ref="authAccount.${realm}.${domain}"/>
    </bean>

    <bean id="AuthRuntimeFactory" class="aws.auth.client.impl.AuthRuntimeClientFactory">
        <property name="authenticateResultCache" ref="CastedAuthNCache"/>
        <property name="policyCache" ref="CastedPolicyCache"/>

        <property name="configuration" ref="ArcConfig"/>
    </bean>

    <bean id="AuthRuntimeClient" factory-bean="AuthRuntimeFactory" factory-method="newAuthRuntimeClient"/>

    <bean id="CachemerePolicyCacheBuilder" class="com.amazon.cachemere.CacheClientBuilder">
        <!-- Local Cache -->
        <property name="localCacheMegabytes" value="64" />
        <property name="localCacheMaximumTtlSeconds" value="#{T(aws.auth.client.config.CacheConfig).DEFAULT_EVICTION_TTL_SECONDS}" />
        <!-- Remote Cache, using LDAP discovery -->
    </bean>
    <bean id="CachemereAuthNCacheBuilder" class="com.amazon.cachemere.CacheClientBuilder">
        <!-- Local Cache -->
        <property name="localCacheMegabytes" value="64" />
        <property name="localCacheMaximumTtlSeconds" value="#{T(aws.auth.client.config.CacheConfig).DEFAULT_EVICTION_TTL_SECONDS}" />
        <!-- Remote Cache, using LDAP discovery -->
    </bean>

    <bean id="CastedAuthNCache" class="amazon.cache.Cache">
        <constructor-arg ref="AuthNCache" />
    </bean>

    <bean id="CastedPolicyCache" class="amazon.cache.Cache">
        <constructor-arg ref="PolicyCache" />
    </bean>

    <bean id="AuthNCache" class="amazon.cache.plugin.cachemere.CachemereJakalPlugin">
        <constructor-arg ref="CachemereAuthNCacheBuilder" />
        <property name="timeToLiveSeconds" value="300" />
        <property name="getTimeoutMillis" value="250" />
    </bean>

    <bean id="PolicyCache" class="amazon.cache.plugin.cachemere.CachemereJakalPlugin">
        <constructor-arg ref="CachemerePolicyCacheBuilder" />
        <property name="timeToLiveSeconds" value="300" />
        <property name="getTimeoutMillis" value="250" />
    </bean>

    <!-- for corp host(beta and bwbeta stack), we have to use prodPreview.us-east-1.
      see wiki https://w.amazon.com/index.php/AWSAuth/Onboarding
      "If you are running a TEST stack of a production service on the corporate network (including corp-attached
      Amazon VPC (MAWS)) and want authentication: ARPS is not for you. Use ARS with qualifier prodPreview.us-east-1 instead."-->
    <util:map id="authQualifierMap">
        <entry key="beta" value="prodPreview.us-east-1"/>
        <entry key="bwbeta" value="prodPreview.us-east-1"/>
        <entry key="gamma" value="prod.${realm}"/>
        <entry key="systest" value="prod.${realm}"/>
        <entry key="prod" value="prod.${realm}"/>
        <entry key="prod-border" value="prod.${realm}"/>
        <entry key="prod-cn" value="prod.${realm}"/>
        <entry key="edge-prod-cn" value="prod.${realm}"/>
    </util:map>

    <bean id="OdinAWSCredentialsProvider" class="amazon.odin.awsauth.OdinAWSCredentialsProvider">
        <constructor-arg value="com.amazon.blackwatch.mitigation_service_crypto_offload.${realm}.${domain}"/>
    </bean>

    <bean id="OdinAWSCredentials" factory-bean="OdinAWSCredentialsProvider" factory-method="getCredentials" />
    <!-- Recasting OdinAWSCredentialsProvider as an aws.auth.client.auth.AWSCredentialsProvider, which is used by ARC -->
    <bean id="CastedAWSCredentialsProvider" class="aws.auth.client.auth.BasicAWSCredentialsProvider">
        <constructor-arg>
            <bean class="aws.auth.client.auth.BasicAWSCredentials">
                <constructor-arg value="#{OdinAWSCredentials.getAWSAccessKeyId()}" />
                <constructor-arg value="#{OdinAWSCredentials.getAWSSecretKey()}" />
           </bean>
        </constructor-arg>
    </bean>

    <bean id="ArcConfig" class="aws.auth.client.config.Configuration">
        <!-- Set the qualifier for selecting the coral client config and ARS endpoint (S3 has a dedicated one, -->
        <!-- if your service does not have, simply put "${domain}.${realm}" -->
        <property name="qualifier" value="#{authQualifierMap['${domain}']}"/>
        <!-- Set vendor name to scope the policies that ARS returns -->
        <property name="vendor" value="lookout"/>
        <!-- Increase number of retries for failed calls -->
        <property name="serviceCallRetryAttempts" value="2"/>
        <!-- Set the initial retry backoff milliseconds, defaults to 0 -->
        <property name="retryInitialBackoffMS" value="500"/>

        <property name="credentialsProvider" ref="CastedAWSCredentialsProvider" />
    </bean>

</beans>
