<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation=
    "http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

    <!--
    Construct an orchestrator using the Orchestrator helper. The only thing
    you'll need to provide is a configured Chain.
    -->
    <bean id="orchestrator" class="com.amazon.coral.service.helper.OrchestratorHelper">
        <constructor-arg>
            <ref bean="chain"/>
        </constructor-arg>
        <!-- Waiting for 2 minutes for coral framework to clean up its threads. (Some context here: https://issues.amazon.com/SF-1578)
             Note: This timeout HAS to be smaller then the shutdownTimeout for the ProcessManager (currently 01/2015 configured to be 200s) to be meaningful, 
                   else the process manager will simply kill the process, without letting spring shutdown the beans it has created. -->
        <constructor-arg value="120000"/> 
    </bean>

    <!-- Configure the Chain which contains the list of Handlers to apply -->
    <bean id="chain" class="com.amazon.coral.service.helper.ChainHelper" depends-on="logger">
        <property name="handlers">
            <list>
                <bean class="com.amazon.coral.service.Log4jAwareRequestIdHandler"/>
                
                <bean class="com.amazon.coral.service.HttpHandler"/>
                <bean class="com.amazon.coral.service.PingHandler"/>
                
                <!-- Here are protocol handlers. You need at least one.-->
                <bean class="com.amazon.coral.service.http.HttpBindingHandler"/>
                <bean class="com.amazon.coral.service.HttpRpcHandler"/>
                
                <!-- ContentHandler has to be before the AuthenticationHandler to be able to use the Explorer. -->
                <bean class="com.amazon.coral.service.http.ContentHandler"/>
                
                <ref bean="AuthenticationHandler"/>
                <ref bean="AuthorizationHandler"/>
                
                <bean class="com.amazon.coral.service.ModelHandler"/>
                <bean class="com.amazon.coral.validate.ValidationHandler"/>
                
                <!-- This always comes last.-->
                <bean class="com.amazon.coral.spring.SpringActivityHandler">
                    <property name="globalInterceptorClassNames">
                        <list>
                            <!-- Log request/reply. See https://w.amazon.com/index.php/Coral/Manual/Logging/RequestLogging -->
                            <value>com.amazon.coral.service.RequestLoggingInterceptor</value>
                        </list>
                    </property>
                </bean>
            </list>
        </property>
    </bean>
    
    <bean class="com.amazon.coral.service.RequestLoggingInterceptor">
        <!--
        The following are the three properties available to control the output
        of the RequestLoggingInterceptor. The values shown are the defaults.
        -->
        <property name="logInput"><value>true</value></property>
        <property name="logOutput"><value>true</value></property>
        <property name="logOnlyOnError"><value>false</value></property>    
    </bean>
    
    <bean id="AuthenticationHandler" class="com.amazon.coral.service.ARSAuthenticationHelper" depends-on="appConfigHelper">
        <constructor-arg ref="AuthNConfig"/>
        <constructor-arg ref="AuthRuntimeClient"/>
    </bean>

    <bean id="AuthNConfig" class="com.amazon.coral.service.AwsAuthNConfig">
        <property name="signingSchemes" value="V4"/>
        <property name="region" value="${realm}"/> <!-- Auth in the same region as the region where the service runs -->
        <property name="service" value="lookout"/>
        <property name="vendorCode" value="lookout"/>
        <property name="headersToSecure" value=""/>
    </bean>

    <!-- 
    Creating beans for authorization based on 
    https://w.amazon.com/index.php/Coral/Manual/AWSAuth/Authorization1.1,
    https://w.amazon.com/index.php/AWSAuth/AuthRuntimeClient/UpgradingTo1.1, and
    https://code.amazon.com/packages/CoralAwsAuthRuntimeDemo/blobs/mainline/\-\-/spring-configuration/coral-service.xml 
    -->
    
    <!-- 
    LookoutMitigationService is an internal service, and is not designed for subscriptions. 
    So just using ARSAuthorizationHandler instead of ARSAuthorizationHelper that combines ARSAuthroizationHandler and ARSSubscriptionCheckHandler 
    -->
    <bean id="AuthorizationHandler" class="com.amazon.coral.service.ARSAuthorizationHandler">
        <constructor-arg ref="AuthRuntimeClient"/>
        <constructor-arg>
            <map>
                <!-- Authorization strategy for individual operations -->
                <!-- All operations must be authorized, and we have a single strategy for all operations-->
                <entry key="LookoutMitigationService/*" value-ref="AuthorizationStrategy"/>
            </map>
        </constructor-arg>
    </bean>

    <!-- Strategy to employ for authorizing calls to LookoutMitigationService -->
    <bean id="AuthorizationStrategy" class="com.amazon.lookout.mitigation.service.authorization.AuthorizationStrategy">
        <constructor-arg ref="ArcConfig"/>
        <constructor-arg value="${realm}"/>
    </bean>

    <bean id="AuthRuntimeFactory" class="aws.auth.client.impl.AuthRuntimeClientFactory">
        <property name="authenticateResultCache" ref="AuthNCache"/>
        <property name="policyCache" ref="PolicyCache"/>
        <property name="configuration" ref="ArcConfig"/>
    </bean>

    <bean id="AuthRuntimeClient" factory-bean="AuthRuntimeFactory" factory-method="newAuthRuntimeClient"/>

    <!--
    HashMapCache are generally disapproved in Prod because real customer traffic could
    overwhelm the cache. We do not expect that many number of diverse clients or very
    high volumes of requests to overwhelm the HashMapCache for LookoutMitigationService.
    -->
    <bean id="AuthNCache" class="amazon.cache.Cache">
        <constructor-arg>
            <bean class="amazon.cache.impl.HashMapCache"/>
        </constructor-arg>
    </bean>

    <bean id="PolicyCache" class="amazon.cache.Cache">
        <constructor-arg>
            <bean class="amazon.cache.impl.HashMapCache"/>
        </constructor-arg>
    </bean>

    <bean id="ArcConfig" class="aws.auth.client.config.Configuration">
        <!-- Set the qualifier for selecting the coral client config and ARS endpoint (S3 has a dedicated one, -->
        <!-- if your service does not have, simply put "${domain}.${realm}" -->
        <property name="Qualifier" value="${domain}.${realm}"/>
        <!-- Set vendor name to scope the policies that ARS returns -->
        <property name="Vendor" value="lookout"/>
        <!-- Increase number of retries for failed calls -->
        <property name="ServiceCallRetryAttempts" value="2"/>
        <!-- Set the initial retry backoff milliseconds, defaults to 0 -->
        <property name="RetryInitialBackoffMS" value="500"/>
    </bean>

</beans>
